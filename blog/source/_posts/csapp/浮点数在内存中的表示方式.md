title: 浮点数在内存中的表示方式
date: 2015-12-26 18:56:17
tags: [浮点数]
---

# 浮点数的定义
浮点数（floating-point number）是属于有理数中某特定子集的数的数字表示，在计算机中用以近似表示任意某个实数。具体来说，这个实数由一个整数或定点数（即尾数）乘以某个基数（计算机中通常是2）的整数次幂得到，这种表示方法类似于基数为10的科学记数法。

浮点计算是指浮点数参与的运算，这种运算通常伴随着因为无法精确表示而进行的近似或舍入。
<!-- more -->
一个浮点数a由两个数m和e来表示：$a = m × b^e$。在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如$±d.ddd...ddd$的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1）。如果m的第一位是非0整数，m称作正规化的。有一些描述使用一个单独的符号位（s 代表+或者-）来表示正负，这样m必须是正的。e是指数。

这种设计可以在某个固定长度的存储空间内表示定点数,但无法表示的更大范围的数。

例如，一个指数范围为±4的4位十进制浮点数可以用来表示43210，4.321或0.0004321，但是没有足够的精度来表示432.123和43212.3（必须近似为432.1和43210）。当然，实际使用的位数通常远大于4。

此外，浮点数表示法通常还包括一些特别的数值：$+∞$和$−∞$（正负无穷大）以及NaN（'Not a Number'）。无穷大用于数太大而无法表示的时候，NaN则指示非法操作或者无法定义的结果。

其中，无穷大，可表示为inf，在内存中的值是，阶码为全1,尾数全0。而NaN则是阶码全1,尾数不全0。

# 准确性
由于浮点数不能表达所有实数，浮点运算与相应的数学运算有所差异，有时此差异极为显著。

比如，二进制浮点数不能表达0.1和0.01，0.1的平方既不是准确的0.01，也不是最接近0.01的可表达的数。单精度（24比特）浮点数表示0.1的结果为
$e=-4 ， s=110011001100110011001101_{(2)}$，即

$0.100000001490116119384765625$
此数的平方是

$0.010000000298023226097399174250313080847263336181640625$
但最接近0.01的可表达的数是

$0.009999999776482582092285156250$
浮点数也不能表达圆周率$\pi$，所以$\tan\frac{\pi}{2}$不等于正无穷，也不会溢出。下面的C语言代码
```C
double pi = 3.1415926535897932384626433832795;
double z = tan(pi/2.0);
```
的计算结果为$16331239353195370.0$，如果用单精度浮点数，则结果为$−22877332.0$。同样的，$\sin \pi\neq 0$。

由于浮点数计算过程中丢失了精度，浮点运算的性质与数学运算有所不同。浮点加法和乘法不符合结合律和分配律。

## 举例说明

单精度浮点数格式 是一种计算机数据格式，在计算机存储器中占用4个字节（32 bits），利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。

在 IEEE 754-2008 的定义中，32-bit base 2格式被正式称为binary32格式。这种格式在IEEE 754-1985被定义为single，即单精度。 需要注意的是，在更早的一些计算机系统中，也存在着其他4字节的浮点数格式。

第1位表示正负，中间8位表示指数，后23位表示有效数位。

正负号0代表正，1代表负。指数可以是二补码；或0到255，前半代表负，127代表零，后半代表正。

有效数位最左手边的1并不会储存，因为它一定存在。二进制的第一个有效数字必定是1。换言之，有效数位是24位，实际储存23位。

![](http://7xi91i.com1.z0.glb.clouddn.com/201512Float_example.svg)
![](http://7xi91i.com1.z0.glb.clouddn.com/Float_example.png)
